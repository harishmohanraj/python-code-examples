{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"python-code-examples","text":"<p>This file will become your README and also the index of your documentation.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install python_code_examples\n</code></pre>"},{"location":"#how-to-use","title":"How to use","text":"<p>Fill me in please! Don\u2019t forget code examples:</p> <pre><code>1+1\n</code></pre> <pre><code>2\n</code></pre>"},{"location":"00_core/","title":"core","text":"<p>source</p>"},{"location":"00_core/#foo","title":"foo","text":"<pre><code> foo ()\n</code></pre>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>python-code-examples</li> <li>core</li> <li>guides<ul> <li>Python Data Model</li> </ul> </li> <li>API<ul> <li>python_code_examples<ul> <li>core<ul> <li>foo</li> </ul> </li> </ul> </li> </ul> </li> <li>CLI<ul> <li>Not found</li> </ul> </li> <li>Releases</li> </ul>"},{"location":"changelog_not_found/","title":"Releases","text":""},{"location":"changelog_not_found/#changelogmd-file-not-found","title":"CHANGELOG.md file not found.","text":"<p>To generate the changelog file, please run the following command from the project root directory. </p> <pre><code>nbdev_changelog\n</code></pre> <p>If you do not want this page to be rendered as part of the documentation, please remove the following line from the mkdocs/summary_template.txt file and build the docs again.</p> <pre><code>- [Releases]{changelog}\n</code></pre>"},{"location":"cli_commands_not_found/","title":"No CLI commands found in console_scripts in settings.ini file.","text":"<p>For documenting CLI commands, please add command line executables in <code>console_scripts</code> in <code>settings.ini</code> file. </p> <p>If you do not want this page to be rendered as part of the documentation, please remove the following lines from the mkdocs/summary_template.txt file and build the docs again.</p> <pre><code>- CLI\n{cli}\n</code></pre>"},{"location":"api/python_code_examples/core/foo/","title":"foo","text":""},{"location":"api/python_code_examples/core/foo/#python_code_examples.core.foo","title":"<code>python_code_examples.core.foo()</code>","text":"Source code in <code>python_code_examples/core.py</code> <pre><code>def foo(): pass\n</code></pre>"},{"location":"guides/Python_Data_Model/","title":"Python Data Model","text":""},{"location":"guides/Python_Data_Model/#special-methods","title":"Special Methods","text":"<p>The special method names are always written with leading and trailing double underscores.</p> <p>For example, the syntax obj[key] is supported by the getitem special method. In order to evaluate my_collection[key], the interpreter calls my_collection.__getitem__(key).</p> <p>Note</p> <p>\u201cWe implement special methods when we want our objects to support and interact with fundamental language constructs such as Collections,  Attribute access, Iteration, etc.</p>"},{"location":"guides/Python_Data_Model/#example-a-pythonic-card-deck","title":"Example: A Pythonic Card Deck","text":"<p>The below class demonstrates the power of implementing just two special methods, getitem and len</p> <pre><code>import collections\n\nCard = collections.namedtuple(\"Card\", [\"rank\", \"suit\"])\n\n\nclass FrenchDeck:\n    ranks = [n for n in range(2, 11)] + list(\"JQKA\")\n    suits = \"spades diamonds clubs hearts\".split()\n\n    def __init__(self):\n        self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]\n\n    def __len__(self):\n        return len(self._cards)\n\n    def __getitem__(self, position):\n        return self._cards[position]\n</code></pre> <p>The FrenchDeck class is short, but it packs a punch.</p> <p>First, like any standard Python collection, a deck responds to the len() function by returning the number of cards in it:</p> <pre><code>deck = FrenchDeck()\nlen(deck)\n</code></pre> <pre><code>52\n</code></pre> <p>Reading specific cards from the deck\u2014say, the first or the last\u2014is easy, thanks to the getitem method:</p> <pre><code>print(deck[0])\nprint(deck[-1])\n</code></pre> <pre><code>Card(rank=2, suit='spades')\nCard(rank='A', suit='hearts')\n</code></pre> <p>Should we create a method to pick a random card? No need. Python already has a function to get a random item from a sequence: <code>random.choice</code>.</p> <p>We can use it on a deck instance:</p> <pre><code>from random import choice\n\nprint(choice(deck))\nprint(choice(deck))\nprint(choice(deck))\n</code></pre> <pre><code>Card(rank='Q', suit='hearts')\nCard(rank=2, suit='diamonds')\nCard(rank='K', suit='spades')\n</code></pre> <p>Because our getitem delegates to the [] operator of self._cards, our deck automatically supports slicing.</p> <p>Here\u2019s how we look at the top three cards from a brand-new deck, and then pick just the Aces by starting at index 12 and skipping 13 cards at a time:</p> <pre><code>print(deck[:3])\nprint(deck[12::13])\n</code></pre> <pre><code>[Card(rank=2, suit='spades'), Card(rank=3, suit='spades'), Card(rank=4, suit='spades')]\n[Card(rank='A', suit='spades'), Card(rank='A', suit='diamonds'), Card(rank='A', suit='clubs'), Card(rank='A', suit='hearts')]\n</code></pre> <p>Just by implementing the getitem special method, our deck is also iterable:</p> <pre><code># We can also iterate over the deck in reverse\n\nfor card in reversed(deck):\n    print(card)\n</code></pre> <pre><code>Card(rank='A', suit='hearts')\nCard(rank='K', suit='hearts')\nCard(rank='Q', suit='hearts')\nCard(rank='J', suit='hearts')\nCard(rank=10, suit='hearts')\nCard(rank=9, suit='hearts')\nCard(rank=8, suit='hearts')\nCard(rank=7, suit='hearts')\nCard(rank=6, suit='hearts')\nCard(rank=5, suit='hearts')\nCard(rank=4, suit='hearts')\nCard(rank=3, suit='hearts')\nCard(rank=2, suit='hearts')\nCard(rank='A', suit='clubs')\nCard(rank='K', suit='clubs')\nCard(rank='Q', suit='clubs')\nCard(rank='J', suit='clubs')\nCard(rank=10, suit='clubs')\nCard(rank=9, suit='clubs')\nCard(rank=8, suit='clubs')\nCard(rank=7, suit='clubs')\nCard(rank=6, suit='clubs')\nCard(rank=5, suit='clubs')\nCard(rank=4, suit='clubs')\nCard(rank=3, suit='clubs')\nCard(rank=2, suit='clubs')\nCard(rank='A', suit='diamonds')\nCard(rank='K', suit='diamonds')\nCard(rank='Q', suit='diamonds')\nCard(rank='J', suit='diamonds')\nCard(rank=10, suit='diamonds')\nCard(rank=9, suit='diamonds')\nCard(rank=8, suit='diamonds')\nCard(rank=7, suit='diamonds')\nCard(rank=6, suit='diamonds')\nCard(rank=5, suit='diamonds')\nCard(rank=4, suit='diamonds')\nCard(rank=3, suit='diamonds')\nCard(rank=2, suit='diamonds')\nCard(rank='A', suit='spades')\nCard(rank='K', suit='spades')\nCard(rank='Q', suit='spades')\nCard(rank='J', suit='spades')\nCard(rank=10, suit='spades')\nCard(rank=9, suit='spades')\nCard(rank=8, suit='spades')\nCard(rank=7, suit='spades')\nCard(rank=6, suit='spades')\nCard(rank=5, suit='spades')\nCard(rank=4, suit='spades')\nCard(rank=3, suit='spades')\nCard(rank=2, suit='spades')\n</code></pre> <p>in operator</p> <pre><code>Card('Q', 'hearts') in deck\n</code></pre> <pre><code>True\n</code></pre> <p>How about sorting?</p> <p>A common system of ranking cards is by rank (with aces being highest), then by suit in the order of spades (highest), hearts, diamonds, and clubs (lowest).</p> <p>Here is a function that ranks cards by that rule, returning 0 for the 2 of clubs and 51 for the ace of spades:</p> <pre><code>suit_values = dict(spades=3, hearts=2, diamonds=1, clubs=0)\n\ndef spades_high(card):\n    rank_value = FrenchDeck.ranks.index(card.rank)\n    return rank_value * len(suit_values) + suit_values[card.suit]\n</code></pre> <p>Given spades_high, we can now list our deck in order of increasing rank:</p> <pre><code>for card in sorted(deck, key=spades_high):\n    print(card)\n</code></pre> <pre><code>Card(rank=2, suit='clubs')\nCard(rank=2, suit='diamonds')\nCard(rank=2, suit='hearts')\nCard(rank=2, suit='spades')\nCard(rank=3, suit='clubs')\nCard(rank=3, suit='diamonds')\nCard(rank=3, suit='hearts')\nCard(rank=3, suit='spades')\nCard(rank=4, suit='clubs')\nCard(rank=4, suit='diamonds')\nCard(rank=4, suit='hearts')\nCard(rank=4, suit='spades')\nCard(rank=5, suit='clubs')\nCard(rank=5, suit='diamonds')\nCard(rank=5, suit='hearts')\nCard(rank=5, suit='spades')\nCard(rank=6, suit='clubs')\nCard(rank=6, suit='diamonds')\nCard(rank=6, suit='hearts')\nCard(rank=6, suit='spades')\nCard(rank=7, suit='clubs')\nCard(rank=7, suit='diamonds')\nCard(rank=7, suit='hearts')\nCard(rank=7, suit='spades')\nCard(rank=8, suit='clubs')\nCard(rank=8, suit='diamonds')\nCard(rank=8, suit='hearts')\nCard(rank=8, suit='spades')\nCard(rank=9, suit='clubs')\nCard(rank=9, suit='diamonds')\nCard(rank=9, suit='hearts')\nCard(rank=9, suit='spades')\nCard(rank=10, suit='clubs')\nCard(rank=10, suit='diamonds')\nCard(rank=10, suit='hearts')\nCard(rank=10, suit='spades')\nCard(rank='J', suit='clubs')\nCard(rank='J', suit='diamonds')\nCard(rank='J', suit='hearts')\nCard(rank='J', suit='spades')\nCard(rank='Q', suit='clubs')\nCard(rank='Q', suit='diamonds')\nCard(rank='Q', suit='hearts')\nCard(rank='Q', suit='spades')\nCard(rank='K', suit='clubs')\nCard(rank='K', suit='diamonds')\nCard(rank='K', suit='hearts')\nCard(rank='K', suit='spades')\nCard(rank='A', suit='clubs')\nCard(rank='A', suit='diamonds')\nCard(rank='A', suit='hearts')\nCard(rank='A', suit='spades')\n</code></pre> <p>By implementing the special methods len and getitem, our FrenchDeck behaves like a standard Python sequence, allowing it to benefit from core language features (e.g., iteration and slicing) and from the standard library, as shown by the examples using random.choice, reversed, and sorted.</p>"},{"location":"guides/Python_Data_Model/#how-special-methods-are-used","title":"How Special Methods Are Used","text":"<p>The first thing to know about special methods is that they are meant to be called by the Python interpreter, and not by you.</p> <p>You don\u2019t write my_object.__len__(). You write len(my_object) and, if my_object is an instance of a user-defined class, then Python calls the len method you implemented.</p> <p>In the next sections, we\u2019ll see some of the most important uses of special methods:</p>"},{"location":"guides/Python_Data_Model/#emulating-numeric-types","title":"Emulating Numeric Types","text":""}]}